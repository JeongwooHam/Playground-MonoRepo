# 💼 package.json 틸드와 캐럿

## 👾 모듈의 버전

- 모듈의 버전이 '1.2.3'이라고 가정했을 떄, 버전은 아래와 같이 명명됩니다.

|   1    |  .  |   2    |  .  |  3   |
| :----: | :-: | :----: | :-: | :--: |
| 메이저 |     | 마이너 |     | 패치 |

- 다시 말해, 버전은 Major.Minor.Patch로 구성된다.

```
👩‍🏫 그리고, 모듈 관리자라면 버전 관리 시 따라야 할 규칙이 있습니다!
```

1. 이전 버전과 호환되지 않는 변경은 메이저 번호를 증가시킨다.

2. 이전 버전과 호환되는 새로운 기능은 마이너 번호를 증가시킨다.

3. 기존 기능에 대한 간단한 버그 수정은 패치 번호를 증가시킨다.

➡️ 이러한 규칙들은 **셈버 규칙**을 따른다.

### 🖥️ 셈버(Semver) 규칙

- Semantic Versioniong의 줄임말
- 의존성이 높은 시스템에서 새 패키지 버전을 발표할 때 발생할 수 있는 의존성 명세 관련 위험을 해결하기 위해 사용된다.
  - 의존성 명세를 너무 엄격하게 관리할 경우 의존하는 모든 패키지의 새 버전을 배포하지 않으면 업그레이드가 불가능해진다.
  - 의존성을 너무 느슨하게 관리할 경우 버전이 뒤섞이는 문제가 발새알 수 있다.
  - 이 때문에 버전에 갇히거나 뒤섞여서 프로젝트의 안전하고 편리한 진행이 불가능해지는 의존성 지옥에 빠질 수 있다.
- 셈버 규칙은 버전 번호를 어떻게 정하고 올려야 할지 명시하는 규칙과 요구 사항을 특정한다.
- 버전 번호와 그 번호를 바꾸는 방법을 체계적으로 정의하여 특정 버전에서 다음 버전으로 넘어가는 과정에서 코드가 어떻게 바뀌었는지를 나타내게 하였다.
- Node.js 뿐만 아니라 npm의 모듈은 모두 셈버 규칙을 따르고 있다.

## **_~_** (Tilde, 틸드)

- Major.Minor.Patch 중 **Patch 범위** 내에서 버전 업데이트
- <code>npm update</code> 시 최신 마이너 버전 이전까지 업데이트 된다.
- Minor는 증가시키지 않고 최신 Patch까지만 업데이트 하는 것!
- 현재 지정한 버전의 마지막 자리 내의 범위에서만 자동 업데이트하는 것으로 이해하면 된다.

> 예시

- **_~3.2.1_**, '>=3.2.1', '<3.3.0'
  - Patch 범위 내에서 버전 업데이트를 진행한다.
  - 범위가 3.2.1을 포함해서 같거나 크고, 3.3.0보다 작은 범위 내의 버전 업데이트를 한다.
  - ~3.2.x 릴리즈를 사용한다.

## **_^_** (Caret, 캐럿)

- Major.Minor.Patch 중 Major 이하 하위 호환성이 보장되는 범위 내(**Minor와 Patch**)에서 버전 업데이트
- <code>npm update</code> 시 최신 마이너 버전까지 업데이트 된다.
- 패키지의 Minor와 Patch까지 변경한다.
- Node.js 모듈이 셈버 규칙을 따른다는 것을 신뢰한다는 전제 하에 동작한다.
  - 따라서 Minor, Patch 버전은 하위 호환성이 보장되어야 하므로 이 부분까지 업데이트 한다.

> 예시

- **_^3.2.1_**, '>=3.2.1', '<4.0.0'
  - Major 이하 하위 호환성이 보장되는 범위 내에서 버전 업데이트를 진행한다.
  - 3.2.1보다 크거나 같고, 3.3.0보다 작은 범위 내에서 업데이트 한다.
  - Major 버전이 바뀌지 않은 상태에서 하위 호환성을 유지하므로 실무에서 많이 사용되는 방법이다.
  - 1.x.x까지의 릴리즈를 사용한다.

### ⚠️ Caret의 예외 사항

- 다음과 같은 경우를 가정해보자.

  - <code>^0.1.2: >=0.1.2 < 0.2.0</code>
  - <code>^0.1: >=0.1.0 <0.2.0</code>
  - <code>^0: >=0.0.0 <1.0.0</code>
  - <code>^0.0.1: ===0.0.1</code>

- 버전이 1.0.0 미만인 경우
  - 셈버 규칙에서는 **pre-release**로 칭한다.
- 대부분의 소프트웨어에서는 1.0 버전을 출시하기 전 API 변경이 수시로 일어난다.
  - 0.1에서 0.2로의 변경이라도 API가 모두 달라졌을 가능성이 있다.
  - 이때문에 0.x.x 수준에서 캐럿 사용 시 지정한 버전 자릿수 내에서만 업데이트가 진행되어 틸드처럼 동작한다.
  - 따라서 마지막 사례의 경우 하위 호환성의 유지가 안 되는 상황을 막기 위해 지정한 버전만을 사용한다.

### 🤠 Caret이 새로운 표준이 되었습니다!

> 처음에는 Tilde가 기본이었다.

- 원래 package.json의 셈버 규칙에서는 틸드가 기본 값이었다.
- <code>npm install</code> 실행 시 package.json에 다음과 같이 기록되었다.

```json
"dependencies": {
    "qs": "~1.2.3"
}
```

- 위의 경우 Patch에 대한 최신 버전을 허용하므로 1.2.5는 허용하지만 1.3.0은 허용하지 않는다.
  - 이때의 업데이트는 기능적으로 이전 버전과 호환되며 대부분의 사용자가 인지하지 못하는 버그 해결에 대한 것이다.

> Caret이 표준이 된 이유

- 셈버 규칙에 따르면 minor은 기존 버전과 기능적으로 호환이 가능하다.
  - 예를 들어, 1.3.5 버전으로 개발했다고 했을 때, 1.9.0 버전을 설치해서 실행해도 문제가 발생하지 않는다.
  - 그리고 1.3.5 버전 대비 1.9.0 버전에 버그가 더 많이 해결되어 있을 것이다.
  - 따라서 기능적으로 문제가 없고 버그는 더 적은 1.9.0으로 배포하는 것이 더 이득이다.
- 이 때문에 버그가 상대적으로 많이 해결되어 있는 캐럿이 표준이 되었다.
  - 셈버 규칙에는 이에 대한 규정이 없었기 때문에 필요성에 따라 Minor에 대한 최신 버전까지의 사용이 가능한 캐럿이 등장한 것이다.
- 다만 외부 라이브러리가 **minor 업데이트 시 이전 버전에 대한 호환성을 지키지 않아 셈버 규칙을 어길 경우** 버그가 발생할 수는 있음에 주의하자.
- npm에서는 1.4.3 버전부터 캐럿이 표준이 되었다.
  - <code>npm install --save</code>, <code>npm install --save-dev</code> 등을 사용할 경우 캐럿으로 버전을 관리한다.

#### 🔎 References

- [package.json 의 version 과 틸드 tilde(~) 그리고 캐럿 caret(^)](https://yzlosmik.tistory.com/m/137)
- [[npm] 버전 관리 기초 지식 (caret, tilde)](https://code-masterjung.tistory.com/31])
- [npm package.json의 verison과 틸드tilde(~)와 캐럿caret(^)](https://umanking.github.io/2022/05/05/npm-version-tilde-caret/)
- [틸드tilde(~)와 캐럿caret(^)의 차이, 어떤 걸 써야 할까? (이슈 회고)](https://bsnn.tistory.com/164)
- [Semantic Versioning, Tilde, Caret](https://pannchat.tistory.com/entry/Semantic-Versioning-Tilde-Caret)
- [npm package.json에서 틸드(~) 대신 캐럿(^) 사용하기](https://blog.outsider.ne.kr/1041)
- [Semantic Versioning 2.0.0](https://semver.org/)
